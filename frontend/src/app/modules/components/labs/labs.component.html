<tabset [justified]="true">
  <tab>
    <ng-template tabHeading>
      <span class="h3">Laboratory №3(Entity)</span>
    </ng-template>
    <div class="container">
      <div *ngIf="true;then lab3">
      </div>
    </div>
  </tab>
  <tab>
    <ng-template tabHeading>
      <span class="h3">Laboratory №7(Spring XML and Annotations)</span>
    </ng-template>
    <div class="container">
      <div *ngIf="true;then lab7">
      </div>
    </div>
  </tab>
  <tab>
    <ng-template tabHeading>
      <span class="h3">Laboratory №8(Spring Boot,Spring MVC)</span>
    </ng-template>
    <div class="container">
      <div *ngIf="true;then lab8">
      </div>
    </div>
  </tab>
  <tab>
    <ng-template tabHeading>
      <span class="h3">Laboratory №9(Spring Data and Hibernate)</span>
    </ng-template>
    <div class="container">
      <div *ngIf="true;then lab9">
      </div>
    </div>
  </tab>
</tabset>

<ng-template #lab3>
  <h4>Entity</h4>
  <p class="text-justify mt-4">
    Entity-компоненты
    Entity-компоненты представляют собой объектное представление данных из БД. Например, Entity-компонент может
    моделировать одну запись из таблицы реляционной базы данных. Несколько клиентов могут одновременно обращаться к
    одному экземпляру такого Компонента. Entity-компоненты изменяют состояние сопоставленных с ними баз данных в
    контексте транзакций.
    Состояние Entity-компонентов в общем случае нужно сохранять, и "живут" они столько, сколько существуют в базе данных
    те данные, которые они представляют, а не столько, сколько существуют клиентский или серверный процессы. Остановка
    или "падение" Контейнера EJB не приводит к уничтожению содержащихся в нем Entity-компонентов.
    За сохранность компонента может отвечать сам Компонент (Bean Managed Persistence, BMP) или его Контейнер (Container
    Managed Persistence, CMP). При использовании CMP все обязанности по сохранению состояния Компонента возлагаются на
    Контейнер. В случае BMP, Вы должны написать для Компонента нужный код, включая обращение к базам данных.
    Каждый Entity-компонент характеризуется своим уникальным идентификатором - primary key. Обычно это тот же самый
    primary key, что и идентификатор данных в БД, например, совокупность ключевых полей записи в таблице.
  </p>
  <img src="assets/labs/lab3.png" class="img-fluid" alt="Responsive image">
  <p class="text-justify mt-2">
    В JPA каждый класс Entity будет соответствовать таблице в базе данных. Имеется очень много таблиц в базе данных
    поэтому будет очень много классов Entity. Вам часто приходится работать с Entity, и нужно написать классы DAO ( Data
    Access Object) чтобы манипулировать с данными через эти Entity, это на самом деле надоедливая работа.
  </p>
  <h4>Вопрос 1. Что такое JPA?</h4>
  <p class="text-justify mt-2">JPA (Java Persistence API) это спецификация Java EE и Java SE, описывающая систему управления сохранением java
    объектов в таблицы реляционных баз данных в удобном виде. Сама Java не содержит реализации JPA, однако есть
    существует много реализаций данной спецификации от разных компаний (открытых и нет). Это не единственный способ
    сохранения java объектов в базы данных (ORM систем), но один из самых популярных в Java мире.</p>
  <h4>Вопрос 2. В чем её отличие JPA от Hibernate?</h4>
  <p class="text-justify mt-2">Hibernate одна из самых популярных открытых реализаций последней версии спецификации (JPA 2.1). Даже скорее самая
    популярная, почти стандарт де-факто. То есть JPA только описывает правила и API, а Hibernate реализует эти описания,
    впрочем у Hibernate (как и у многих других реализаций JPA) есть дополнительные возможности, не описанные в JPA (и не
    переносимые на другие реализации JPA).</p>
  <h4>Вопрос 5. Что такое Entity?</h4>
  <p class="text-justify mt-2">Entity это легковесный хранимый объект бизнес логики (persistent domain object). Основная программная сущность это
    entity класс, который так же может использовать дополнительные классы, который могут использоваться как
    вспомогательные классы или для сохранения состояния еntity.</p>
  <h4>Вопрос 10. Какие требования JPA к Entity классам вы можете перечислить (не менее шести требований)?</h4>
  <ul>
    <li>Entity класс должен быть отмечен аннотацией Entity или описан в XML файле конфигурации JPA,</li>
    <li>Entity класс должен содержать public или protected конструктор без аргументов (он также может иметь конструкторы
      с аргументами),
    </li>
    <li>Entity класс должен быть классом верхнего уровня (top-level class),</li>
    <li>Entity класс не может быть enum или интерфейсом,</li>
    <li>Entity класс не может быть финальным классом (final class),</li>
    <li>Entity класс не может содержать финальные поля или методы, если они участвуют в маппинге (persistent final
      methods or persistent final instance variables),
    </li>
    <li>Если объект Entity класса будет передаваться по значению как отдельный объект (detached object), например через
      удаленный интерфейс (through a remote interface), он так же должен реализовывать Serializable интерфейс,
    </li>
    <li> Поля Entity класс должны быть напрямую доступны только методам самого Entity класса и не должны быть напрямую
      доступны другим классам, использующим этот Entity. Такие классы должны обращаться только к методам (getter/setter
      методам или другим методам бизнес-логики в Entity классе),
    </li>
    <li>Enity класс должен содержать первичный ключ, то есть атрибут или группу атрибутов которые уникально определяют
      запись этого Enity класса в базе данных,
    </li>
  </ul>

  <h4></h4>
  <p></p>
</ng-template>


<ng-template #lab7>
  <h4> Введение</h4>
  <p class="text-justify mt-4">
    Inversion of Control (IoC), также известное как Dependency Injection (DI), является процессом, согласно которому
    объекты определяют свои зависимости, т.е. объекты, с которыми они работают, через аргументы конструктора/фабричного
    метода или свойства, которые были установлены или возвращены фабричным методом. Затем контейнер inject(далее
    "внедряет") эти зависимости при создании бина. Этот процесс принципиально противоположен, поэтому и назван Inversion
    of Control, т.к. бин сам контролирует реализацию и расположение своих зависимостей, используя прямое создание
    классов или такой механизм, как шаблон Service Locator.
    Основными пакетами Spring Framework IoC контейнера являются org.springframework.beans и org.springframework.context.
    Интерфейс BeanFactory предоставляет механизм конфигурации по управлению любым типом объектов. ApplicationContext -
    наследует нитерфейс BeanFactory и добавляет более специфичную функциональность. </p>
  <p class="text-justify mt-2">
    В большинстве случаев предпочтительно использовать ApplicationContext, поэтому в дальнейшем будет использоваться
    только он и его реализации. Поскольку он включает в себя всю функциональность BeanFactory, его можно и нужно
    использовать, за исключением случаев, когда приложение запускается на устройствах с ограниченными ресурсами, в
    которых объем потребляемой памяти может быть критичным, даже в пределах нескольких килобайт, либо когда вы
    разрабатываете приложение, в котором необходима поддержка совместимости со сторонними библиотеками, использующими
    JDK 1.4 или не поддерживают JSR-250. Spring Framework активно использует BeanPostProcessor для проксирования и др.,
    поэтому, если вам необходима поддержка такой функциональности, как AOP и транзакций, то при использовании
    BeanFactory необходимо добавить вручную регистрацию BeanPostProcessor и BeanFactoryPostProcessor
  </p>
  <h4>Описание работы IoC контейнера</h4>
  <p class="text-justify mt-2">
    Ниже представлена диаграмма, отражающая, как работает Spring. Ваши классы приложения совмещаются с метаданными
    конфигурации, в результате чего будет создан и инициализирован ApplicationContext, а на выходе вы получите полностью
    настроенное и готовое к выполнению приложение.
  </p>
  <img src="assets/labs/lab7.png" class="img-fluid" alt="Responsive image">
  <p class="text-justify mt-2">В метаданных конфигурации разработчик описывает как инициализировать, настроить IoC
    контейнер и собрать объекты в вашем приложении. </p>
  <h4>Настройка IoC контейнера</h4>
  <p class="text-justify mt-2">
    Основными признаками и частями Java-конфигурации IoC контейнера являются классы с аннотацией @Configuration и методы
    с аннотацией @Bean. Аннотация @Bean используется для указания того, что метод создает, настраивает и инициализирует
    новый объект, управляемый Spring IoC контейнером. Такие методы можно использовать как в классах с аннотацией
    @Configuration, так и в классах с аннотацией @Component(или её наследниках). Класс с аннотацией @Configuration
    говорит о том, что он является источником определения бинов.
  </p>
  <h4>Области видимости(scopes) бинов</h4>
  <p>
    Когда вы создаете определение бинов, вы вы создаете рецепт для создания экземпляров класса, который определяет бин.
    Важно понять, что определение бинов является рецептом, потому что он означает, какого класса вы можете создать
    множество экземпляров по этому рецепту.

    Вы можете контролировать не только какие зависимости и значения конфигурации вы можете подключить в объекте, который
    создан из определения бина, но также область видимости из того же определения бина. Это мощный и гибкий подход, при
    котором вы можете выбрать область видимости создаваемых объектов. Изначально, Spring Framework поддерживает
    несколько вариантов, некоторые доступны, только если вы используете web-aware ApplicationContext. Также вы можете
    создать свою собственную облать видимости. Ниже приведен список областей видимостей, описанных в документации на
    момент написания урока:

    singleton - По умолчанию. Spring IoC контейнер создает единственный экземпляр бина. Как правило, используется для
    бинов без сохранения состояния(stateless)

    prototype - Spring IoC контейнер создает любое количество экземпляров бина. Новый экземпляр бина создается каждый
    раз, когда бин необходим в качестве зависимости, либо через вызов getBean(). Как правило, используется для бинов с
    сохранением состояния(stateful)

    request - Жизненный цикл экземпляра ограничен единственным HTTP запросом; для каждого нового HTTP запроса создается
    новый экземпляр бина. Действует, только если вы используете web-aware ApplicationContext

    session - Жизненный цикл экземпляра ограничен в пределах одной и той же HTTP Session. Действует, только если вы
    используете web-aware ApplicationContext

    global session - Жизненный цикл экземпляра ограничен в пределах глобальной HTTP Session(обычно при использовании
    portlet контекста). Действует, только если вы используете web-aware ApplicationContext

    application - Жизненный цикл экземпляра ограничен в пределах ServletContext. Действует, только если вы используете
    web-aware ApplicationContext

    Для того, чтобы указать область видимости бина, отличный от singleton, необходимо добавить аннотацию
    @Scope("область_видимости") методу объявления бина или классу с аннотацией @Component:
  </p>
  <p>
    Дескриптор сообщает Spring о необходимости сканирования кода на предмет внедряемых context: component-scan> бинов,
    аннотированных с помощью и , а также поддерживающих @Component, @Controller, @Repository @Service аннотации и в
    указанном пакете (и всех eгo внутренних пакетах). В дескрипторе context: @Autowired @Inject component-scan> можно
    определить множество пакетов, используя в качестве разделителя запятую, точку запятой или пробел. Кроме того, для
    более детализированного управления этот дескриптор поддерживает включение и исключение сканирования компонентов.
    Основные аннотации, используемые в Spring DI:

    @Component - Аннотация для любого компонента фреймворка.

    @Service - Аннотация, объявляющая, что этот класс представляет собой сервис, содержащий бизнес-логику приложения.
    Сервис является подтипом класса @Component. Использование данной аннотации позволит искать бины-сервисы
    автоматически.

    @Repository - Аннотация показывает, что класс функционирует как репозиторий (класс доступа к источнику данных,
    например, к базе данных) и требует наличия прозрачной трансляции исключений (exceptions). @Controller - Аннотация
    для маркировки java класса, как класса контроллера. Используется в Web-приложениях, разработанных с использованием
    фрэймворка Spring MVC.
    Кроме платформа Spring предоставляет большое количество других пространств имен, предназначенных для beans
    разнообразных целей. В их число входят для конфигурации ApplicationContext, для поддержки АОП и для context аор tx
    поддержки транзакций. Для использования поддержки аннотаций Spring внутри своего приложения в конфигурации XML
    необходимо объявить дескрипторы context: component-scan>.

  </p>
  <h4>Аннотации</h4>
  <p class="text-justify mt-4">
    @Component - Аннотация для любого компонента фреймворка.

    @Service - (Сервис-слой приложения) Аннотация, объявляющая, что этот класс представляет собой сервис – компонент
    сервис-слоя.

    Сервис является подтипом класса @Component. Использование данной аннотации позволит искать бины-сервисы
    автоматически.

    @Repository - (Доменный слой) Аннотация показывает, что класс функционирует как репозиторий и требует наличия
    прозрачной трансляции исключений. Преимуществом трансляции исключений является то, что слой сервиса будет иметь дело
    с общей иерархией исключений от Spring (DataAccessException) вне зависимости от используемых технологий доступа к
    данным в слое данных.

    @Controller - (Слой представления) Аннотация для маркировки java класса, как класса контроллера. Данный класс
    представляет собой компонент, похожий на обычный сервлет (HttpServlet) (работающий с объектами HttpServletRequest и
    HttpServletResponse), но с расширенными возможностями от Spring Framework.

    @ResponseBody - Аннотация показывает что данный метод может возвращать кастомный объект в виде xml, json...

    @RestController - Аннотация аккумулирует поведение двух аннотаций @Controller и @ResponseBody

    @Transactional - Перед исполнением метода помеченного данной аннотацией начинается транзакция, после выполнения
    метода транзакция коммитится, при выбрасывании RuntimeException откатывается.

    @Autowired - Аннотация позволяет автоматически установить значение поля.

    @RequestMapping - Аннотация используется для маппинга урл-адреса запроса на указанный метод или класс. Можно
    указывать конкретный HTTP-метод, который будет обрабатываться (GET/POST), передавать параметры запроса.

    @ModelAttribute - Аннотация, связывающая параметр метода или возвращаемое значение метода с атрибутом модели,
    которая будет использоваться при выводе jsp-страницы.

    @PathVariable - Аннотация, которая показывает, что параметр метода должен быть связан с переменной из урл-адреса.

    @Scope - Аннотация для установки области жизни бина: singleton (только один экземпляр бина создается для IoC
    контейнера; значение по умолчанию ), prototype (создается новый экземпляр бина когда приходит запрос на его
    создание), request (один экземпляр бина для каждого HTTP запроса ), session (один экземпляр бина для каждой сессии),
    globalSession (один экземпляр бина для каждой глобальной сессии)

    @PostConstruct - Аннотация для метода, который будет вызван после вызова конструктора бина.

    @PreDestroy - Аннотация для метода, который будет вызван перед уничтожением бина.

    @Profile - Аннотация для создания профилей конфигурации проекта. Может применяться как к бинам так и к
    конфигурационным классам.
  </p>
  <h4>Выбор между поиском и внедрением</h4>
  <p class="text-justify mt-2">
    Выбор используемого стиля IoC часто определяется используемым контейнером. Например, при использовании старых
    контейнеров (EJB2.1 и ранее) доступен только Dependency Lookup. Однако все современные контейнеры (Spring, EJB3.1 и
    выше, и др.) предоставляют возможность использования обоих типов реализации IoC.
    В том случае, когда есть выбор, конечно, предпочтительнее использовать Dependency Injection. Во-первых, это проще.
    Во-вторых, применение внедрения зависимостей оказывает нулевое воздействие на код компонентов. В-третьих,
    существенно упрощается тестирование компонентов. Но самым замечательным моментом является то, что внедряемые
    компоненты просто хранятся в полях объекта и для их извлечения не требуется никакого действия. Пассивный код не
    только проще сопровождать, в нем гораздо меньше вероятность возникновения ошибок. </p>
  <h4>Выбор между Setter Injection и Constructor Injection</h4>
  <p class="text-justify mt-2">
    Теперь, когда мы определились, что более предпочтительным методом IoC является Dependency Injection, осталось
    выбрать применяемую разновидность: внедрение через метод (сеттер) или через конструктор.
    Constructor Injection особенно удобен, когда перед использованием компонента обязательно должен существовать
    экземпляр внедряемого объекта. В этом случае контейнер перед тем, как создавать экземпляр класса, проверяет, все ли
    зависимости определены. Кроме того, Constructor Injection помогает достичь применения неизменяемых объектов.
    Setter Injection так же полезен во многих случаях. Один из самых распространенных примеров применения этого вида
    внедрения - передача настроек объекту контейнером. Другим достоинством этого метода является наличие возможности
    замены внедряемого объекта "налету", без необходимости пересоздания родительского объекта. Но главное достоинство
    этого способа заключается в том, что этот способ является самым ненавязчивым из всех существующих. Объект будет
    создан даже в том случае, если внедряемый компонент не найден или не инициализирован. </p>
  <h4>Выбор между XML и Annotation конфигурациями</h4>
  <p class="text-justify mt-2">
    Когда мы рассмотрели оба способа конфигурации, резонно возникает вопрос: какой из двух способов предпочтительнее
    использовать - XML или аннотации?
    Использование аннотаций безусловно проще и позволяет разработчику определять и видеть конфигурацию внутри кода. Но
    использование XML позволяет вынести конфигурацию за пределы Java-кода и изменять конфигурацию приложения без
    необходимости рекомпиляции и сборки проекта.
    Поэтому в момент написания кода и при разработке небольших изолированных приложений более удобным является способ
    конфигурации через аннотации, но при работе над крупными проектами, а так же при передаче готового решения в
    production более предпочтительным является конфигурация через XML.
    Тем не менее, Spring позволяет одновременно использовать оба вида конфигурации, сочетая конфигурацию через аннотации
    для конфигурации внедряемых бинов через аннотации, и конфигурацию инфраструктуры (например, фабрики по работе с
    базами данных, диспетчер транзакций, фабрики подключения к службам JMS, JMX и др.) - через XML. </p>
</ng-template>

<ng-template #lab8>
  <h4>Model-View-Controller Pattern</h4>
  <p>MVC - это шаблон, который часто используется при реализации уровня презентаций в приложении. Главный принцип
    шаблона MVC состоит в определении архитектуры с четкими ответственностями для каждого компонента. В шаблоне MVC
    присутствуют три участника:
    Модель представляет бизнес-данные, а также "состояние" приложения внутри контекста конкретного пользователя.
    Например, на веб-сайте электронной коммерции модель будет включать информацию профиля пользователя, данные корзины
    для покупок и данные заказа, если пользователи приобретают товары на этом сайте. Представление отображает данные
    пользователю в желаемом формате, поддерживает взаимодействие с пользователями и выполняет проверку достоверности с
    клиентской стороны, интернационализацию, оформление стилями и т.д. Контроллер обрабатывает запросы к действиям,
    осуществляемые пользователями в пользовательском интерфейсе, взаимодействуя с уровнем обслуживания, обновляя модель
    и направляя пользователей на соответствующие представления в зависимости от результатов выполнения.

    Опираясь на шаблон Model-View-Controller MVC), фреймворк Spring MVC помогает строить веб-приложения, столь же гибкие
    и слабо связанные, как сам фреймворк Spring Framework. Вместе с модулем Spring MVC можно применять разнообразные
    технологии представлений (например, JSP или Velocity). Вдобавок Spring МVС интегрируется со многими известными
    веб-платформами и наборами инструментов (в том числе Angular и GWT).
  </p>
  <h4>Жизненный цикл запроса в Spring MVC</h4>
  <p>Когда запрос покидает браузер, он несет в себе информацию о требовании пользователя. По крайней мере, запрос будет
    нести в себе запрошенный URL. Но он может также нести дополнительные данные, такие как информация из формы,
    заполненной пользователем.

    Первой остановкой на пути запроса является DispatcherServlet. Как и большинство веб-фреймворков на языке Java,
    фреймворк Spring MVC пропускает все входящие запросы через единственный сервлет входного контроллера. Входной
    контроллер (front controller) является типичным шаблоном проектирования веб-приложений, где единственный сервлет
    берет на себя ответственность за передачу всех запросов остальным компонентам приложения, выполняющим фактическую их
    обработку. В Spring MVC входным контроллером является DispatcherServlet. Задача контроллера DispatcherServlet
    состоит в том, чтобы передать запрос контроллеру Spring MVC. Контроллер – это компонент Spring, обрабатывающий
    запрос. Но приложение может иметь несколько контроллеров, и входному контроллеру DispatcherServlet требуется помощь,
    чтобы определить, какому контроллеру передать запрос. Поэтому контроллер DispatcherServlet консультируется c одним
    или несколькими механизмами отображения и выясняет, где будет следующая остановка запроса. При принятии решения
    механизм отображения в первую очередь руководствуется адресом URL в запросе.

    Как только будет выбран соответствующий контроллер, DispatcherServlet отправляет запрос в путь к выбранному
    контроллеру. Достигнув контроллера, запрос отдаст информацию, отправленную пользователем, и будет ждать, пока
    контроллер обработает эту информацию. (На самом деле хорошо спроектированный контроллер сам почти не занимается
    обработкой информации, вместо этого он делегирует ответственность за обработку одному или нескольким служебным
    объектам).

    В результате работы контроллера часто появляется некоторая информация, которая должна быть передана назад
    пользователю и отображена в браузере. Эта информация называется моделью. Но отправки обратно необработанной
    информации недостаточно, перед отправкой ее следует представить в удобном для пользователя формате, обычно в HTML.
    Для этого информация должна быть передана в одно из представлений, которыми обычно являются JSP.
    Последнее, что должен сделать контроллер, – упаковать вместе модель и имя представления для отображения результатов
    в браузере. Затем он отсылает запрос вместе с моделью и именем представления обратно входному контроллеру
    DispatcherServlet.

    Чтобы контроллер не оказался тесно связанным с каким-либо конкретным представлением, имя представления, возвращаемое
    входному контроллеру DispatcherServlet, не определяет JSP-страницу непосредственно. Фактически оно даже не
    предполагает, что представление вообще является страницей JSP. Оно является лишь логическим именем представления,
    используемым затем для поиска фактического представления. Чтобы отобразить логическое имя представления в ссылку на
    конкретную реализацию, входной контроллер DispatcherServlet обращается к арбитру представлений (view resolver).
    Теперь, когда контроллер DispatcherServlet определил, какое представление будет отображать результаты, работа
    запроса подошла к концу. Его конечная остановка – реализация представления (возможно, страница JSP), куда он
    доставит модель данных. На этом работа запроса заканчивается. На основе модели данных представление создаст
    отображение страницы, которое будет отправлено обратно клиенту с другим курьером – объектом ответа.
  </p>
  <h4>Spring Boot
  </h4>
  <p>Spring Boot позволяет легко создавать полноценные Spring-приложения, про которые можно сказать - "просто запусти".
    Возможности
  </p>
  <ul>
    <li>Создание полноценных Spring приложений</li>
    <li>Встроенный Tomcat или Jetty (не требуется установки WAR файлов)</li>
    <li>Обеспечивает 'начальные' POMs для упрощения Maven конфигураци</li>
    <li>Автоматическая конфигурирация Spring везде, где это возможно</li>
    <li>Конфигурация без необходимости генерации кода и без написания XML</li>
    <li>Обеспечивает такими возможностями, как метрики, мониторинг состояниями и расширенная конфигурация</li>
  </ul>
  <h4></h4>
  <p></p>
</ng-template>

<ng-template #lab9>
  <div class="text-justify mt-4">
    <h4>Spring Data</h4>
    <h4></h4>
    <p>
      При проектировании информационной системы выявляются некоторые слои, которые отвечают за взаимодействие различных
      модулей системы. Соединение с базой данных является одной из важнейшей составляющей приложения. Всегда выделяется
      часть кода, модуль, отвечающающий за передачу запросов в БД и обработку полученных от неё ответов. В общем случае,
      определение Data Access Object описывает его как прослойку между БД и системой. DAO абстр агирует сущности системы
      и
      делает их отображение на БД, определяет общие методы использования соединения, его получение, закрытие и (или)
      возвращение в Connection Pool.
      Вершиной иерархии DAO является абстрактный класс или интерфейс с описанием общих методов, которые будут
      использоваться при взаимодействии с базой данных. Как правило, это методы поиска, удаление по ключу, обновление и
      т.д.
    </p>
    <p class="text-justify mt-4">
      Spring Data — дополнительный удобный механизм для взаимодействия с сущностями базы данных, организации их в
      репозитории, извлечение данных, изменение, в каких то случаях для этого будет достаточно объявить интерфейс и
      метод
      в нем, без имплементации.
    </p>
    <h4>1. Spring Repository</h4>
    <p>
      Основное понятие в Spring Data — это репозиторий. Это несколько интерфейсов которые используют JPA Entity для
      взаимодействия с ней. Так например интерфейс
      обеспечивает основные операции по поиску, сохранения, удалению данных (CRUD операции)
      Есть и другие абстракции, например PagingAndSortingRepository.
      Т.е. если того перечня что предоставляет интерфейс достаточно для взаимодействия с сущностью, то можно прямо
      расширить базовый интерфейс для своей сущности, дополнить его своими методами запросов и выполнять операции. </p>
    <h4>2. Методы запросов из имени метода</h4>
    <p class="text-justify mt-4">
      Запросы к сущности можно строить прямо из имени метода. Для этого используется механизм префиксов find…By,
      read…By,
      query…By, count…By, и get…By, далее от префикса метода начинает разбор остальной части. Вводное предложение может
      содержать дополнительные выражения, например, Distinct. Далее первый By действует как разделитель, чтобы указать
      начало фактических критериев. Можно определить условия для свойств сущностей и объединить их с помощью And и
      Or. </p>
    <h4>3. Специальная обработка параметров</h4>
    <p class="text-justify mt-4">
      В методах запросов, в их параметрах можно использовать специальные параметры Pageable, Sort, а также ограничения
      Top
      и First.</p>
    <h4>1. Что такое Hibernate Framework?</h4>
    <p>Hibernate — это библиотека с открытым исходным кодом (open source) для Java, предназначенная для решения задач
      ORM
      (object-relational mapping, объектно-реляционного отображения). Она представляет собой свободное программное
      обеспечение, распространяемое на условиях GNU Lesser General Public License. Hibernate Framework имеет легкий в
      использовании каркас для отображения объектно-ориентированной модели данных в традиционные реляционные базы данных
      и
      предоставляет стандартные средства JPA.</p>

    <h4>2. Преимущества использования Hibernate Framework?</h4>
    <p>Библиотека Hibernate является одним из самых востребованных ORM фреймворков для Java, поскольку :
      позволяет разработчику сосредоточиться на бизнес логике, не отвлекаясь на управление ресурсами;
      предоставляет собственный язык запросов (HQL), внешне похожий на SQL. Необходимо отметить, что HQL полностью
      объектно-ориентирован и понимает такие принципы, как наследование, полиморфизм и ассоциации (связи);
      может использовать также чистый SQL, а, следовательно, поддерживает возможность оптимизации запросов и работы с
      любым сторонним провайдером БД;
      поддерживает JPA аннотации, что позволяет сделать реализацию кода независимой;
      поддерживает разные уровни cache, а следовательно может повысить производительность;
      поддерживает ленивую инициализацию используя proxy объекты и выполняя запросы к базе данных только по
      необходимости;
      интегрируется с другими Java EE фреймворками; например, Spring Framework поддерживает встроенную интеграцию с
      Hibernate;
      является широко распространенным open source продуктом. Благодаря этому доступны тысячи открытых статей, примеров,
      а
      также документация по использованию фреймворка.</p>
    <h4>4. Конфигурационный файл Hibernate</h4>
    <p>Файл конфигурации hibernate.cfg.xml содержит информацию о базе данных (драйвер, пул подключений, диалект) и
      параметрах подключения к серверу БД (url, login, password). В качестве параметров подключения можно использовать
      как
      JDBC, так и JNDI. В файле конфигурации также определяются дополнительные параметры, которые будут использованы при
      работе с сервером БД, Так, здесь необходимо определить маппинги сущностей/классов.
      Чтобы отобразить в консоли SQL-скрипты, генерируемые Hibernate, необходимо в hibernate.cfg.xml определить истиное
      значение свойства «show_sql». Помните, что это необходимо использовать только на уровне разработки и тестирования.
      В
      финальной версии свойство «show_sql» должно быть отключено.
    </p>
    <h4>5. Файл mapping</h4>
    <p>Файл отображения (mapping file) используется для связи entity бинов с таблицами базы данных. Содержимое файла
      имеет
      формат XML. Файл mapping можно использовать вместо аннотаций JPA. Особенно он становится необходимым при
      использовании сторонних библиотек.
    </p>
  </div>
</ng-template>
